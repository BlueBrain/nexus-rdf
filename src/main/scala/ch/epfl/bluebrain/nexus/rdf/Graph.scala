package ch.epfl.bluebrain.nexus.rdf

import cats.implicits._
import cats.{Eq, Functor, Monad, Show}
import ch.epfl.bluebrain.nexus.rdf.Graph._
import ch.epfl.bluebrain.nexus.rdf.Node.{blank, IriNode, IriOrBNode}
import ch.epfl.bluebrain.nexus.rdf.Vocabulary._
import ch.epfl.bluebrain.nexus.rdf.cursor.GraphCursor
import ch.epfl.bluebrain.nexus.rdf.encoder.{GraphEncoder, RootNode}
import scalax.collection.edge.LkDiEdge
import scalax.collection.immutable.{Graph => G}

/**
  * An RDF Graph representation.
  */
@SuppressWarnings(Array("IsInstanceOf"))
class Graph private[rdf] (private[rdf] val underlying: G[Node, LkDiEdge]) { self =>

  /**
    * @return the triples of this graph
    */
  lazy val triples: Set[Triple] =
    foldLeft(Set.empty[Triple])(_ + _)

  /**
    * @return true if the graph has at least one cycle, false otherwise
    */
  lazy val isCyclic: Boolean =
    underlying.isCyclic

  /**
    * @return true if the graph has no cycles, false otherwise
    */
  lazy val isAcyclic: Boolean =
    underlying.isAcyclic

  /**
    * @return true if all the triples are connected through the nodes, false otherwise
    */
  lazy val isConnected: Boolean =
    underlying.isConnected

  private def selectAs[A](s: IriOrBNode => Boolean,
                          p: IriNode => Boolean,
                          o: Node => Boolean,
                          f: ((IriOrBNode, IriNode, Node)) => A): Set[A] =
    underlying.edges.foldLeft(Set.empty[A]) {
      case (acc, e) if s(e.s) && p(e.p) && o(e.o) => acc + f((e.s, e.p, e.o))
      case (acc, _)                               => acc
    }

  /**
    * @param s the triple subject used to test matches
    * @param p the triple predicate used to test matches
    * @param o the triple objects used to test matches
    * @return the triples found from the provided subject, predicate and object functions
    */
  def select(s: IriOrBNode => Boolean = _ => true,
             p: IriNode => Boolean = _ => true,
             o: Node => Boolean = _ => true): Set[(IriOrBNode, IriNode, Node)] =
    selectAs(s, p, o, identity)

  /**
    * @param p the triple predicate
    * @param o the triple object
    * @return the subjects found from the provided predicate and object
    */
  def subjects(p: IriNode => Boolean = _ => true, o: Node => Boolean = _ => true): Set[IriOrBNode] =
    selectAs(_ => true, p, o, { case (s, _, _) => s })

  /**
    * @param s the triple subject
    * @param o the triple object
    * @return the predicates found from the provided subject and object
    */
  def predicates(s: IriOrBNode => Boolean = _ => true, o: Node => Boolean = _ => true): Set[IriNode] =
    selectAs(s, _ => true, o, { case (_, p, _) => p })

  /**
    * @param s the triple subject used to test matches
    * @param p the triple predicate used to test matches
    * @return the objects found from the provided subject and predicate
    */
  def objects(s: IriOrBNode => Boolean = _ => true, p: IriNode => Boolean = _ => true): Set[Node] =
    selectAs(s, p, _ => true, { case (_, _, o) => o })

  /**
    * Adds the triple identified by (s, p, o) arguments to this graph.
    *
    * @param s the triple subject
    * @param p the triple predicate
    * @param o the triple object
    * @return a new graph made up of all of the triples of this graph and the triple created from the arguments
    */
  def add(s: IriOrBNode, p: IriNode, o: Node): Graph =
    new Graph(underlying + LkDiEdge(s, o)(p))

  /**
    * Adds the provided object to the subject ''s'' and predicate ''p'' to this graph.
    * The triples on the object are generated by the provided [[GraphEncoder]]
    *
    * @param s     the triple subject
    * @param p     the triple predicate
    * @param value the value to add
    * @return a new graph made up of all of the triples of this graph and the triple created from the arguments
    */
  def addObject[F[_]: Functor, A: RootNode](s: IriOrBNode, p: IriNode, value: A)(
      implicit enc: GraphEncoder[F, A]): F[Graph] =
    enc(value).map(elem => self + ((s, p, elem.rootNode)) ++ elem)

  /**
    * Adds the provided collection (sorted) to the subject ''s'' and predicate ''p'' to this graph.
    * The triples on the collection are generated by the provided [[GraphEncoder]]
    *
    * @param s    the triple subject
    * @param p    the triple predicate
    * @param list the collection to add
    * @return a new graph made up of all of the triples of this graph and the triple created from the arguments
    */
  def add[F[_], A: RootNode](s: IriOrBNode, p: IriNode, list: List[A])(implicit enc: GraphEncoder[F, A],
                                                                       F: Monad[F]): F[Graph] = {

    def inner(ss: IriOrBNode, rest: List[A], triples: Set[Triple]): F[Set[Triple]] =
      rest match {
        case Nil => F.pure(triples)
        case h :: Nil =>
          enc(h).map(elem =>
            triples ++ Set[Triple]((ss, rdf.first, elem.rootNode), (ss, rdf.rest, rdf.nil)) ++ elem.triples)
        case h :: t =>
          enc(h).flatMap { elem =>
            val nextSubject = blank
            val graph       = triples ++ Set[Triple]((ss, rdf.first, elem.rootNode), (ss, rdf.rest, nextSubject)) ++ elem.triples
            inner(nextSubject, t, graph)
          }
      }

    val listBNode = blank
    inner(listBNode, list, Set[Triple]((s, p, listBNode))).map(triples => self ++ Graph(triples))
  }

  /**
    * Adds the argument triple to this graph.
    *
    * @param spo the triple to add
    * @return a new graph made up of all of the triples of this graph and the argument triple
    */
  def +(spo: (IriOrBNode, IriNode, Node)): Graph = {
    val (s, p, o) = spo
    add(s, p, o)
  }

  /**
    * Removes the triple identified by (s, p, o) arguments if it's contained.
    *
    * @param s the triple subject
    * @param p the triple predicate
    * @param o the triple object
    * @return a new graph made up of all of the triples of this graph except the triple created from the arguments
    */
  def remove(s: IriOrBNode, p: IriNode, o: Node): Graph = {
    val edge = LkDiEdge(s, o)(p)
    new Graph(underlying -! edge)
  }

  /**
    * Removes the triples that match the expressions in s, p and o.
    *
    * @param s the triple subject
    * @param p the triple predicate
    * @param o the triple object
    * @return a new graph made up of all of the triples of this graph except the triples matching s and p and o
    */
  def remove(s: IriOrBNode => Boolean = _ => true,
             p: IriNode => Boolean = _ => true,
             o: Node => Boolean = _ => true): Graph = {
    val remaining = underlying.edges.foldLeft(Set.empty[LkDiEdge[Node]]) {
      case (acc, e) if s(e.s) && p(e.p) && o(e.o) => acc
      case (acc, e)                               => acc + LkDiEdge(e.s, e.o)(e.p)
    }
    new Graph(G.from(Set.empty, remaining))
  }

  /**
    * Removes the argument triple from this graph if it's contained.
    *
    * @param spo the triple to remove
    * @return a new graph made up of all of the triples of this graph except the argument triple
    */
  def -(spo: (IriOrBNode, IriNode, Node)): Graph = {
    val (s, p, o) = spo
    remove(s, p, o)
  }

  /**
    * Joins this graph with that graph.
    *
    * @param that the graph to join
    * @return the union of this and that graphs
    */
  def union(that: Graph): Graph =
    new Graph(underlying ++ that.underlying)

  /**
    * Joins this graph with that graph.
    *
    * @param that the graph to join
    * @return the union of this and that graphs
    */
  def ++(that: Graph): Graph =
    union(that)

  /**
    * Removes all the triples of that graph that are contained in this graph.
    *
    * @param that the graph containing the triples to remove
    * @return a new graph that contains only the triples in this graph that are not contained in that graph
    */
  def subtract(that: Graph): Graph =
    new Graph(underlying --! that.underlying.edges)

  /**
    * Removes all the triples of that graph that are contained in this graph.
    *
    * @param that the graph containing the triples to remove
    * @return a new graph that contains only the triples in this graph that are not contained in that graph
    */
  def --(that: Graph): Graph =
    subtract(that)

  /**
    * Replaces the ''target'' node with the provided ''value'' node.
    *
    * @param target the node to be replaced
    * @param value  the replacement value
    * @return a new [[Graph]] with the same triples but a replacement on the subject or object from ''target'' to ''value''
    */
  def replaceNode(target: Node.IriOrBNode, value: Node.IriOrBNode): Graph =
    Graph(triples.map {
      case (`target`, p, `target`) => (value, p, value)
      case (`target`, p, o)        => (value, p, o)
      case (s, p, `target`)        => (s, p, value)
      case default                 => default
    })

  /**
    * @param node the node where to start the cursor traversal
    * @return an initial cursor from the provided ''node''
    */
  def cursor(node: IriOrBNode): GraphCursor =
    GraphCursor(node, self)

  private def foldLeft[Z](z: Z)(f: (Z, (IriOrBNode, IriNode, Node)) => Z): Z =
    underlying.edges.foldLeft(z) {
      case (acc, e) => f(acc, (e.s, e.p, e.o))
    }

  private implicit class EdgeOps(e: underlying.EdgeT) {
    def s: IriOrBNode = e.from.toOuter.asInstanceOf[IriOrBNode]
    def p: IriNode    = e.label.asInstanceOf[IriNode]
    def o: Node       = e.to
  }

  override def toString: String = underlying.toString()
  override def hashCode(): Int  = underlying.hashCode()
  override def equals(obj: Any): Boolean =
    obj != null && obj.isInstanceOf[Graph] && obj.asInstanceOf[Graph].underlying == underlying
}

object Graph {
  type Triple = (IriOrBNode, IriNode, Node)

  /**
    * Constructs a new graph from the argument triples.
    *
    * @param triples the triples to be added to the graph
    * @return a new graph from the argument triples
    */
  final def apply(triples: Triple*): Graph =
    apply(triples.toSet)

  /**
    * Constructs a new graph from the argument triples.
    *
    * @param triples the triples to be added to the graph
    * @return a new graph from the argument triples
    */
  final def apply(triples: Set[Triple]): Graph = {
    val edges = triples.foldLeft(Set.empty[LkDiEdge[Node]]) {
      case (es, (s, p, o)) => es + LkDiEdge(s, o)(p)
    }
    new Graph(G.from(Set.empty, edges))
  }

  final implicit def graphShow(implicit N: Show[Node]): Show[Graph] =
    Show.show(
      _.triples
        .map {
          case (s, p, o) => s"(${N.show(s)} ${N.show(p)} ${N.show(o)})"
        }
        .mkString("\n"))

  final implicit val graphEq: Eq[Graph] = Eq.fromUniversalEquals
}
