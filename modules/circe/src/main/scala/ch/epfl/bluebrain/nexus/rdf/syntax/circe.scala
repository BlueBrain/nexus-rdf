package ch.epfl.bluebrain.nexus.rdf.syntax

import java.io.{ByteArrayInputStream, ByteArrayOutputStream}

import cats.syntax.show._
import ch.epfl.bluebrain.nexus.rdf.Graph
import ch.epfl.bluebrain.nexus.rdf.Node.Literal.xsd
import ch.epfl.bluebrain.nexus.rdf.Node.{IriNode, IriOrBNode}
import ch.epfl.bluebrain.nexus.rdf.syntax.jena._
import com.github.jsonldjava.core.JsonLdOptions
import io.circe.parser._
import io.circe.syntax._
import io.circe.{Json, JsonObject}
import org.apache.jena.query.DatasetFactory
import org.apache.jena.rdf.model.{Model, ModelFactory}
import org.apache.jena.riot.system.RiotLib
import org.apache.jena.riot.{JsonLDWriteContext, Lang, RDFDataMgr, RDFFormat}

import scala.util.Try

object circe {

  final implicit class CirceOps(private val json: Json) {

    /**
      * Convert Json-LD into [[Graph]]
      * @return [[Graph]] object created from given JSON-LD
      */
    def asGraph: Graph = {
      val model = ModelFactory.createDefaultModel()
      RDFDataMgr.read(model, new ByteArrayInputStream(json.noSpaces.getBytes), Lang.JSONLD)
      model
    }
  }

  final implicit class GraphOps(private val graph: Graph) {

    private val knownTypes: Set[String] =
      Set(xsd.boolean.show, xsd.int.show, xsd.integer.show, xsd.string.show, xsd.decimal.show, xsd.long.show)

    /**
      * Convert [[Graph]] into JSON-LD representation. Value of `@context` will be generated by Jena
      * @return [[Json]] containing JSON-LD representation of the [[Graph]]
      */
    def asJson: Json = {
      val out = new ByteArrayOutputStream()
      RDFDataMgr.write(out, graph, RDFFormat.JSONLD)
      parse(out.toString).getOrElse(Json.obj())
    }

    /**
      * Filter out context which are strings/iris as Jena doesn't  handle them. Other invalid contexts(booleans, numbers) etc.
      * will by handled by Jena and cause an error.
      *
      * @param context context to filter
      * @return Some if the context is not a string, None otherwise
      */
    private def filterIriContext(context: Json): Option[Json] = (context.asString, context.asArray) match {
      case (Some(_), _) => None
      case (_, Some(_)) => Some(context.mapArray(arr => arr.filterNot(_.isString)))
      case (_, _)       => Some(context)
    }

    /**
      * Convert [[Graph]] into JSON-LD representation using provided context. Beware, that currently IRI contexts are
      * not resolved and will be ignored.
      *
      * @param id the optionally provided initial entity @id
      * @param context context to use when creating JSON-LD representation
      * @return [[Json]] containing JSON-LD representation of the [[Graph]]
      */
    def asJson(context: Json, id: Option[IriOrBNode]): Try[Json] =
      (context.asObject.flatMap(_("@context")).flatMap(filterIriContext), id) match {
        case (Some(c), Some(iri: IriNode)) => writeFramed(c, iri)
        case (Some(c), _)                  => write(c)
        case _                             => Try(asJson)
      }

    private def writeFramed(c: Json, id: IriNode): Try[Json] = {
      val opts = new JsonLdOptions()
      opts.setEmbed(true)
      opts.setProcessingMode(JsonLdOptions.JSON_LD_1_1)
      opts.setCompactArrays(true)
      opts.setPruneBlankNodeIdentifiers(true)
      opts.setUseNativeTypes(true)
      val context = Json.obj("@context" -> deleteKnownTypes(c))
      val frame   = context deepMerge Json.obj("@id" -> Json.fromString(id.show))
      val ctx     = new JsonLDWriteContext
      ctx.setFrame(frame.noSpaces)
      ctx.setOptions(opts)
      write(RDFFormat.JSONLD_FRAME_FLAT, ctx).map(_ deepMerge Json.obj("@context" -> c))
    }

    private def write(c: Json): Try[Json] = {
      val opts = new JsonLdOptions()
      opts.setUseNativeTypes(true)
      val context = Json.obj("@context" -> deleteKnownTypes(c))
      val ctx     = new JsonLDWriteContext
      ctx.setJsonLDContext(context.noSpaces)
      ctx.setOptions(opts)
      write(RDFFormat.JSONLD, ctx).map(_ deepMerge Json.obj("@context" -> c))
    }

    private def write(format: RDFFormat, ctx: JsonLDWriteContext): Try[Json] = {
      val g   = DatasetFactory.wrap(graph).asDatasetGraph
      val out = new ByteArrayOutputStream()
      val w   = RDFDataMgr.createDatasetWriter(format)
      val pm  = RiotLib.prefixMap(g)
      Try {
        w.write(out, g, pm, null, ctx)
      }.flatMap(_ => parse(out.toString).map(removeSingleGraph).toTry)
    }

    private def removeSingleGraph(json: Json): Json =
      (json.hcursor.downField("@graph").focus.flatMap(_.asArray).flatMap {
        case head +: IndexedSeq() => Some(head)
        case _                    => None
      }, json.asObject) match {
        case (Some(entity), Some(obj)) => entity deepMerge obj.remove("@graph").asJson
        case _                         => json
      }

    /**
      * Work around for Jena to replace the keys which are in a context with @type
      * and using the UseNativeTypes flag in the JsonLdOptions
      */
    private def deleteKnownTypes(ctx: Json): Json = {
      val m = model(Json.obj("@context" -> ctx))

      def inner(ctx: Json): Json =
        ctx.arrayOrObject(ctx, arr => Json.fromValues(arr.map(inner)), obj => deleteType(obj).asJson)

      def deleteType(jObj: JsonObject): JsonObject =
        JsonObject.fromIterable(
          jObj.toVector
            .filter {
              case ("@type", j) => j.asString.map(s => !knownTypes.contains(m.expandPrefix(s))).getOrElse(true)
              case _            => true
            }
            .map { case (k, v) => k -> inner(v) })

      inner(ctx)
    }
  }

  private def model(json: Json): Model = {
    val m = ModelFactory.createDefaultModel()
    RDFDataMgr.read(m, new ByteArrayInputStream(json.noSpaces.getBytes), Lang.JSONLD)
    m
  }
}
